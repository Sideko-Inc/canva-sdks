// Generated by Sideko (sideko.dev)
package canva_connect_api

import (
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"time"
)

type Client struct {
	httpClient *http.Client
	baseUrl    string
	auth       map[string]func(*http.Request)
}

// Instantiate a new API client
func NewClient(auth ...func(*Client)) *Client {
	baseUrl := `https://api.canva.com/rest/v1`
	httpClient := http.Client{Timeout: time.Duration(10) * time.Second}

	client := Client{httpClient: &httpClient, baseUrl: baseUrl, auth: map[string]func(*http.Request){}}
	for _, a := range auth {
		a(&client)
	}

	return &client
}

func WithBearerAuth(val string) func(*Client) {
	return func(c *Client) {
		c.auth["bearerAuth"] = func(request *http.Request) {
			request.Header.Add("Authorization", "Bearer "+val)
		}
	}
}

func (c *Client) addAuth(authNames []string, request *http.Request) {
	for _, authName := range authNames {
		provider, exists := c.auth[authName]
		if !exists {
			continue
		}
		provider(request)
	}
}

// Updates base url of API client
func (c *Client) SetBaseUrl(url string) {
	c.baseUrl = url
}

// Returns base url of API client
func (c *Client) BaseUrl() string {
	return c.baseUrl
}

// Sets request timeout of client
func (c *Client) SetTimeout(timeout time.Duration) {
	httpClient := http.Client{Timeout: timeout}
	c.httpClient = &httpClient
}

// Returns timeout
func (c *Client) Timeout() time.Duration {
	return c.httpClient.Timeout
}

func (c *Client) ListAllDesigns(request ListAllDesignsRequest) (GetDesignsResponse, error) {
	// URL formatting
	rawUrl, err := url.JoinPath(c.baseUrl, "/designs")
	if err != nil {
		return GetDesignsResponse{}, err
	}

	targetUrl, err := url.Parse(rawUrl)
	if err != nil {
		return GetDesignsResponse{}, err
	}

	// Add query params
	queryParams := targetUrl.Query()
	if request.Continuation != nil {
		// the request might need to be *request
		addQueryParam(queryParams, "continuation", request.Continuation, false)
	}
	if request.Ownership != nil {
		// the request might need to be *request
		addQueryParam(queryParams, "ownership", request.Ownership, false)
	}
	if request.Query != nil {
		// the request might need to be *request
		addQueryParam(queryParams, "query", request.Query, false)
	}
	if request.SortBy != nil {
		// the request might need to be *request
		addQueryParam(queryParams, "sort_by", request.SortBy, false)
	}
	targetUrl.RawQuery = queryParams.Encode()

	// Prep request & add authentication
	req, err := http.NewRequest(
		"GET",
		targetUrl.String(),
		nil,
	)
	if err != nil {
		return GetDesignsResponse{}, err
	}
	c.addAuth(
		[]string{"bearerAuth"},
		req,
	)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return GetDesignsResponse{}, err
	}
	defer resp.Body.Close()

	// handle known status codes
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return GetDesignsResponse{}, err
	}
	switch {
	case resp.StatusCode == 200:
		var data GetDesignsResponse
		err = json.Unmarshal(body, &data)
		if err != nil {
			return GetDesignsResponse{}, err
		}
		return data, nil
	default:
		err = UnexpectedResponseCodeError{
			StatusCode: resp.StatusCode,
			Method:     req.Method,
			Url:        req.URL.String(),
			Data:       body,
			Request:    *req,
			Response:   *resp,
			ExpectedResponseCodes: []string{
				"200",
			},
		}
		return GetDesignsResponse{}, err
	}
}
