"""Generated by Sideko (sideko.dev)"""

import typing

import httpx
from urllib.parse import quote_plus

from canva_connect_api.schemas import *
import canva_connect_api.auth as sdk_auth
import canva_connect_api.errors as sdk_errors
import canva_connect_api.response as sdk_response


T = typing.TypeVar("T")


class AsyncClient:
    def __init__(
        self,
        *,
        bearer_auth: typing.Optional[str] = None,
        base_url: typing.Optional[str] = None,
    ):
        url = base_url or "https://api.canva.com/rest/v1"
        self.base_url = url
        self.session = httpx.AsyncClient()

        # register auth providers
        self._auth: typing.Dict[str, sdk_auth.AuthProvider] = {}
        self._auth["bearerAuth"] = sdk_auth.AuthBearer(val=bearer_auth)

    def _to_encodable(self, target: typing.Any) -> typing.Any:
        if isinstance(target, list):
            return [self._to_encodable(el) for el in target]
        dump_method = getattr(target, "model_api_dump", None)
        if callable(dump_method):
            return target.model_api_dump()

        return target

    def _format_param(
        self,
        value: typing.Union[str, int, typing.List[typing.Union[str, int]], dict],
        explode: bool,
    ) -> typing.List[typing.Union[str, int]]:
        if isinstance(value, (list, dict)) and not explode:
            return quote_plus(",".join(map(str, value)))
        else:
            return value

    def _add_auth(self, auth_names: typing.List[str], **req_kwargs) -> typing.Dict:
        for auth_name in auth_names:
            provider = self._auth.get(auth_name, None)
            if provider is not None:
                req_kwargs = provider.add_auth(req_kwargs)

        return req_kwargs

    async def list_all_designs(
        self,
        *,
        continuation: typing.Optional[str] = None,
        ownership: typing.Optional[GetDesignsOwnershipEnum] = None,
        query: typing.Optional[str] = None,
        sort_by: typing.Optional[GetDesignsSortByEnum] = None,
        timeout: typing.Optional[httpx.Timeout] = None,
    ) -> GetDesignsResponse:
        """ """
        _endpoint = f"/designs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if continuation is not None:
            _params["continuation"] = continuation
        if ownership is not None:
            _params["ownership"] = ownership
        if query is not None:
            _params["query"] = query
        if sort_by is not None:
            _params["sort_by"] = sort_by
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, timeout=timeout, **_authed_kwargs)
        if not _raw_response.content:
            return None
        if _raw_response.status_code == 200:
            return sdk_response.cast_response(_raw_response, GetDesignsResponse)
        raise sdk_errors.InvalidResponseBodyException(
            response=_raw_response, expected_type=GetDesignsResponse
        )
